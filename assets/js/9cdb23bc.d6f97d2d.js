"use strict";(self.webpackChunkwebsite_new=self.webpackChunkwebsite_new||[]).push([[4061],{92554(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"developer/pipeline","title":"Pipeline Architecture","description":"This document describes the pipeline architecture, which uses a Directed Acyclic","source":"@site/docs/developer/pipeline.md","sourceDirName":"developer","slug":"/developer/pipeline","permalink":"/docs/developer/pipeline","draft":false,"unlisted":false,"editUrl":"https://github.com/barebaric/rayforge/tree/main/website/docs/docs/developer/pipeline.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerSidebar","previous":{"title":"Importer Architecture","permalink":"/docs/developer/importer"},"next":{"title":"Tasker: Background Task Management","permalink":"/docs/developer/tasker"}}');var s=i(74848),t=i(28453);const c={},a="Pipeline Architecture",d={},l=[{value:"Artifact Nodes and the Dependency Graph",id:"artifact-nodes-and-the-dependency-graph",level:2},{value:"ArtifactNode",id:"artifactnode",level:3},{value:"Node States",id:"node-states",level:3},{value:"PipelineGraph",id:"pipelinegraph",level:3},{value:"DagScheduler",id:"dagscheduler",level:2},{value:"ArtifactManager",id:"artifactmanager",level:2},{value:"Shared Memory Lifecycle",id:"shared-memory-lifecycle",level:2},{value:"Ownership Patterns",id:"ownership-patterns",level:3},{value:"Reference Counting",id:"reference-counting",level:3},{value:"Pipeline Stages",id:"pipeline-stages",level:2},{value:"InvalidationScope",id:"invalidationscope",level:2},{value:"Input",id:"input",level:2},{value:"Pipeline Core",id:"pipeline-core",level:2},{value:"Pipeline (Orchestrator)",id:"pipeline-orchestrator",level:3},{value:"DagScheduler",id:"dagscheduler-1",level:3},{value:"ArtifactManager",id:"artifactmanager-1",level:3},{value:"Artifact Generation",id:"artifact-generation",level:2},{value:"WorkPieceArtifacts",id:"workpieceartifacts",level:3},{value:"StepArtifacts",id:"stepartifacts",level:3},{value:"JobArtifact",id:"jobartifact",level:3},{value:"ViewManager (Separated)",id:"viewmanager-separated",level:2},{value:"RenderContext",id:"rendercontext",level:3},{value:"WorkPieceViewArtifacts",id:"workpieceviewartifacts",level:3},{value:"Lifecycle",id:"lifecycle",level:3},{value:"Consumers",id:"consumers",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"pipeline-architecture",children:"Pipeline Architecture"})}),"\n",(0,s.jsx)(n.p,{children:"This document describes the pipeline architecture, which uses a Directed Acyclic\nGraph (DAG) to orchestrate artifact generation. The pipeline transforms raw\ndesign data into final outputs for visualization and manufacturing, with\ndependency-aware scheduling and efficient artifact caching."}),"\n",(0,s.jsx)(n.mermaid,{value:'graph TD\n    subgraph Input["1. Input"]\n        InputNode("Input<br/>Doc Model")\n    end\n\n    subgraph PipelineCore["2. Pipeline Core"]\n        Pipeline["Pipeline<br/>(Orchestrator)"]\n        DAG["DagScheduler<br/>(Graph & Task Launching)"]\n        Graph["PipelineGraph<br/>(Dependency Graph)"]\n        AM["ArtifactManager<br/>(Cache)"]\n    end\n\n    subgraph ArtifactGen["3. Artifact Generation"]\n        subgraph WorkPieceNodes["3a. WorkPiece Nodes"]\n            WP["WorkPieceArtifact<br/><i>Local Ops, Vertices, Textures</i>"]\n        end\n\n        subgraph StepNodes["3b. Step Nodes"]\n            SR["StepRenderArtifact<br/><i>World-space Vertices & Textures</i>"]\n            SO["StepOpsArtifact<br/><i>World-space Ops</i>"]\n        end\n\n        subgraph JobNode["3c. Job Node"]\n            JA["JobArtifact<br/><i>Final G-code, Time</i>"]\n        end\n    end\n\n    subgraph ViewMgr["4. View Manager (Separated)"]\n        VM["ViewManager"]\n        VC["RenderContext<br/>(Zoom, Pan, etc.)"]\n        WV["WorkPieceViewArtifact<br/><i>Rasterized for 2D Canvas</i>"]\n    end\n\n    subgraph Consumers["5. Consumers"]\n        Vis2D("2D Canvas (UI)")\n        Vis3D("3D Canvas (UI)")\n        Simulator("Simulator (UI)")\n        File("G-code File (for Machine)")\n    end\n\n    InputNode --\x3e Pipeline\n    Pipeline --\x3e DAG\n    DAG --\x3e Graph\n    DAG --\x3e AM\n\n    Graph --\x3e|"Dirty Nodes"| DAG\n    DAG --\x3e|"Launch Tasks"| WP\n    DAG --\x3e|"Launch Tasks"| SR\n    DAG --\x3e|"Launch Tasks"| SO\n    DAG --\x3e|"Launch Tasks"| JA\n\n    AM -.->|"Cache"| WP\n    AM -.->|"Cache"| SR\n    AM -.->|"Cache"| SO\n    AM -.->|"Cache"| JA\n\n    WP --\x3e Vis2D\n    WP --\x3e VM\n    SR --\x3e Vis3D\n    SO --\x3e DAG\n    JA --\x3e Simulator\n    JA --\x3e File\n\n    VC --\x3e VM\n    VM --\x3e WV\n    WV --\x3e Vis2D\n\n    classDef clusterBox fill:#fff3e080,stroke:#ffb74d80,stroke-width:1px,color:#1a1a1a\n    classDef inputNode fill:#e1f5fe80,stroke:#03a9f480,color:#0d47a1\n    classDef coreNode fill:#f3e5f580,stroke:#9c27b080,color:#4a148c\n    classDef artifactNode fill:#e8f5e980,stroke:#4caf5080,color:#1b5e20\n    classDef viewNode fill:#fff8e180,stroke:#ffc10780,color:#e65100\n    classDef consumerNode fill:#fce4ec80,stroke:#e91e6380,color:#880e4f\n    class Input,PipelineCore,ArtifactGen,WorkPieceNodes,StepNodes,JobNode,ViewMgr,Consumers clusterBox\n    class InputNode inputNode\n    class Pipeline,DAG,Graph,AM coreNode\n    class WP,SR,SO,JA artifactNode\n    class VM,VC,WV viewNode\n    class Vis2D,Vis3D,Simulator,File consumerNode'}),"\n",(0,s.jsx)(n.h1,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(n.h2,{id:"artifact-nodes-and-the-dependency-graph",children:"Artifact Nodes and the Dependency Graph"}),"\n",(0,s.jsxs)(n.p,{children:["The pipeline uses a ",(0,s.jsx)(n.strong,{children:"Directed Acyclic Graph (DAG)"})," to model artifacts and\ntheir dependencies. Each artifact is represented as an ",(0,s.jsx)(n.code,{children:"ArtifactNode"})," in the\ngraph."]}),"\n",(0,s.jsx)(n.h3,{id:"artifactnode",children:"ArtifactNode"}),"\n",(0,s.jsx)(n.p,{children:"Each node contains:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ArtifactKey"}),": A unique identifier consisting of an ID and a group type\n(",(0,s.jsx)(n.code,{children:"workpiece"}),", ",(0,s.jsx)(n.code,{children:"step"}),", ",(0,s.jsx)(n.code,{children:"job"}),", or ",(0,s.jsx)(n.code,{children:"view"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State"}),": The current lifecycle state of the node"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependencies"}),": List of nodes this node depends on (children)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependents"}),": List of nodes that depend on this node (parents)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"node-states",children:"Node States"}),"\n",(0,s.jsx)(n.p,{children:"Nodes progress through four states:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"State"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"DIRTY"})}),(0,s.jsx)(n.td,{children:"The artifact needs to be regenerated"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PROCESSING"})}),(0,s.jsx)(n.td,{children:"A task is currently generating the artifact"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VALID"})}),(0,s.jsx)(n.td,{children:"The artifact is ready and up-to-date"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERROR"})}),(0,s.jsx)(n.td,{children:"Generation failed"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"When a node is marked as dirty, all its dependents are also marked dirty,\npropagating invalidation up the graph."}),"\n",(0,s.jsx)(n.h3,{id:"pipelinegraph",children:"PipelineGraph"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"PipelineGraph"})," is built from the Doc model and contains:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["One node for each ",(0,s.jsx)(n.code,{children:"(WorkPiece, Step)"})," pair"]}),"\n",(0,s.jsx)(n.li,{children:"One node for each Step"}),"\n",(0,s.jsx)(n.li,{children:"One node for the Job"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Dependencies are established:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Steps depend on their ",(0,s.jsx)(n.code,{children:"(WorkPiece, Step)"})," pair nodes"]}),"\n",(0,s.jsx)(n.li,{children:"Job depends on all Steps"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"dagscheduler",children:"DagScheduler"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"DagScheduler"})," is the central orchestrator of the pipeline. It owns the\n",(0,s.jsx)(n.code,{children:"PipelineGraph"})," and is responsible for:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Building the graph"})," from the Doc model"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identifying ready nodes"})," (DIRTY with all VALID dependencies)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Launching tasks"})," to generate artifacts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tracking state"})," through the generation process"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Notifying consumers"})," when artifacts are ready"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The scheduler works with generation IDs to track which artifacts belong to\nwhich document version, allowing reuse of valid artifacts across generations."}),"\n",(0,s.jsx)(n.p,{children:"Key behaviors:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When the graph is built, the scheduler syncs node states with the\nartifact manager to identify cached artifacts that can be reused"}),"\n",(0,s.jsx)(n.li,{children:"Artifacts from the previous generation can be reused if they remain valid"}),"\n",(0,s.jsx)(n.li,{children:"The scheduler tracks which generation IDs have running tasks to preserve\nartifacts during generation transitions"}),"\n",(0,s.jsx)(n.li,{children:"Invalidations are tracked even before graph rebuild and re-applied after"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"artifactmanager",children:"ArtifactManager"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ArtifactManager"})," is a pure cache manager for artifact handles. It:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stores and retrieves artifact handles"}),"\n",(0,s.jsx)(n.li,{children:"Manages reference counting for cleanup"}),"\n",(0,s.jsx)(n.li,{children:"Handles lifecycle (creation, retention, release)"}),"\n",(0,s.jsx)(n.li,{children:"Does NOT track state (state is managed by the DAG scheduler)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"shared-memory-lifecycle",children:"Shared Memory Lifecycle"}),"\n",(0,s.jsxs)(n.p,{children:["Artifacts are stored in shared memory (",(0,s.jsx)(n.code,{children:"multiprocessing.shared_memory"}),") for\nefficient inter-process communication between worker processes and the main\nprocess. The ",(0,s.jsx)(n.code,{children:"ArtifactStore"})," manages the lifecycle of these memory blocks."]}),"\n",(0,s.jsx)(n.h3,{id:"ownership-patterns",children:"Ownership Patterns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Local Ownership:"})," The creating process owns the handle and releases it\nwhen done. This is the simplest pattern."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Inter-Process Handoff:"}),' A worker creates an artifact, sends it to the\nmain process via IPC, and transfers ownership. The worker "forgets" the\nhandle (closes its file descriptor without unlinking the memory), while\nthe main process "adopts" it and becomes responsible for eventual release.']}),"\n",(0,s.jsx)(n.h3,{id:"reference-counting",children:"Reference Counting"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ArtifactStore"})," maintains reference counts for each shared memory block.\nMultiple callers can ",(0,s.jsx)(n.code,{children:"retain()"})," a handle, and the block is only unlinked\nwhen the count reaches zero. This is used by the ",(0,s.jsx)(n.code,{children:"ViewManager"})," for\nprogressive rendering where multiple callbacks may access the same artifact."]}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-stages",children:"Pipeline Stages"}),"\n",(0,s.jsxs)(n.p,{children:["The pipeline stages (",(0,s.jsx)(n.code,{children:"WorkPiecePipelineStage"}),", ",(0,s.jsx)(n.code,{children:"StepPipelineStage"}),",\n",(0,s.jsx)(n.code,{children:"JobPipelineStage"}),") now serve as interfaces rather than task launchers:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"They handle invalidation requests from the UI"}),"\n",(0,s.jsx)(n.li,{children:"They delegate task launching to the DagScheduler"}),"\n",(0,s.jsx)(n.li,{children:"They provide access to cached artifacts"}),"\n",(0,s.jsx)(n.li,{children:"They forward signals from the scheduler to the UI"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"invalidationscope",children:"InvalidationScope"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"InvalidationScope"})," enum defines the scope of invalidation for downstream\nartifacts:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Scope"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FULL_REPRODUCTION"})}),(0,s.jsx)(n.td,{children:"Invalidates workpieces, which cascades to steps and then to the job. Used for changes that require artifact regeneration (geometry, parameters, size changes)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"STEP_ONLY"})}),(0,s.jsx)(n.td,{children:"Invalidates steps directly, which cascades to the job. Used for position/rotation-only transform changes where workpiece geometry remains unchanged."})]})]})]}),"\n",(0,s.jsx)(n.h1,{id:"detailed-breakdown",children:"Detailed Breakdown"}),"\n",(0,s.jsx)(n.h2,{id:"input",children:"Input"}),"\n",(0,s.jsxs)(n.p,{children:["The process begins with the ",(0,s.jsx)(n.strong,{children:"Doc Model"}),", which contains:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"WorkPieces:"})," Individual design elements (SVGs, images) placed on canvas"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Steps:"})," Processing instructions (Contour, Raster) with settings"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-core",children:"Pipeline Core"}),"\n",(0,s.jsx)(n.h3,{id:"pipeline-orchestrator",children:"Pipeline (Orchestrator)"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Pipeline"})," class is the high-level conductor that:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Listens to the Doc model for changes"}),"\n",(0,s.jsx)(n.li,{children:"Coordinates with the DagScheduler to trigger regeneration"}),"\n",(0,s.jsx)(n.li,{children:"Manages the overall processing state"}),"\n",(0,s.jsx)(n.li,{children:"Connects signals between components"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dagscheduler-1",children:"DagScheduler"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"DagScheduler"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Builds and maintains the ",(0,s.jsx)(n.code,{children:"PipelineGraph"})]}),"\n",(0,s.jsx)(n.li,{children:"Identifies nodes ready for processing"}),"\n",(0,s.jsx)(n.li,{children:"Launches tasks via the TaskManager"}),"\n",(0,s.jsx)(n.li,{children:"Tracks node state transitions"}),"\n",(0,s.jsx)(n.li,{children:"Emits signals when artifacts are ready"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"artifactmanager-1",children:"ArtifactManager"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ArtifactManager"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Caches artifact handles in shared memory"}),"\n",(0,s.jsx)(n.li,{children:"Manages reference counting for cleanup"}),"\n",(0,s.jsx)(n.li,{children:"Provides lookup by ArtifactKey and generation ID"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"artifact-generation",children:"Artifact Generation"}),"\n",(0,s.jsx)(n.h3,{id:"workpieceartifacts",children:"WorkPieceArtifacts"}),"\n",(0,s.jsxs)(n.p,{children:["Generated for each ",(0,s.jsx)(n.code,{children:"(WorkPiece, Step)"})," combination, containing:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Toolpaths (",(0,s.jsx)(n.code,{children:"Ops"}),") in local coordinate system"]}),"\n",(0,s.jsx)(n.li,{children:"Vertex data for lines"}),"\n",(0,s.jsx)(n.li,{children:"Texture data for raster fills"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Processing sequence:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modifiers:"})," (Optional) Image conditioning (grayscale, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Producer:"})," Creates raw toolpaths (",(0,s.jsx)(n.code,{children:"Ops"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transformers:"})," Per-workpiece modifications (Tabs, Smooth)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Vertex Encoder:"})," Creates GPU-friendly data"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"stepartifacts",children:"StepArtifacts"}),"\n",(0,s.jsx)(n.p,{children:"Generated for each Step, consuming all related WorkPieceArtifacts:"}),"\n",(0,s.jsx)(n.p,{children:"**StepRenderArtifact:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Combined vertex and texture data for all workpieces"}),"\n",(0,s.jsx)(n.li,{children:"Transformed to world-space coordinates"}),"\n",(0,s.jsx)(n.li,{children:"Optimized for 3D canvas rendering"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"**StepOpsArtifact:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Combined Ops for all workpieces"}),"\n",(0,s.jsx)(n.li,{children:"Transformed to world-space coordinates"}),"\n",(0,s.jsx)(n.li,{children:"Includes per-step transformers (Optimize, Multi-Pass)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"jobartifact",children:"JobArtifact"}),"\n",(0,s.jsx)(n.p,{children:"Generated on demand when G-code is needed, consuming all StepOpsArtifacts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Final G-code for the entire job"}),"\n",(0,s.jsx)(n.li,{children:"Complete vertex data for simulation"}),"\n",(0,s.jsx)(n.li,{children:"High-fidelity time estimate"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"viewmanager-separated",children:"ViewManager (Separated)"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ViewManager"})," is ",(0,s.jsx)(n.strong,{children:"decoupled"})," from the data pipeline. It handles rendering\nfor the 2D canvas based on UI state:"]}),"\n",(0,s.jsx)(n.h3,{id:"rendercontext",children:"RenderContext"}),"\n",(0,s.jsx)(n.p,{children:"Contains the current view parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Pixels per millimeter (zoom level)"}),"\n",(0,s.jsx)(n.li,{children:"Viewport offset (pan)"}),"\n",(0,s.jsx)(n.li,{children:"Display options (show travel moves, etc.)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"workpieceviewartifacts",children:"WorkPieceViewArtifacts"}),"\n",(0,s.jsxs)(n.p,{children:["The ViewManager creates ",(0,s.jsx)(n.code,{children:"WorkPieceViewArtifacts"})," that:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rasterize WorkPieceArtifacts to screen space"}),"\n",(0,s.jsx)(n.li,{children:"Apply the current RenderContext"}),"\n",(0,s.jsx)(n.li,{children:"Are cached and updated when context or source changes"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["ViewManager tracks source ",(0,s.jsx)(n.code,{children:"WorkPieceArtifact"})," handles"]}),"\n",(0,s.jsx)(n.li,{children:"When render context changes, ViewManager triggers re-rendering"}),"\n",(0,s.jsx)(n.li,{children:"When source artifact changes, ViewManager triggers re-rendering"}),"\n",(0,s.jsx)(n.li,{children:"Throttling prevents excessive updates during continuous changes"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ViewManager indexes views by ",(0,s.jsx)(n.code,{children:"(workpiece_uid, step_uid)"})," to support\nvisualizing intermediate states of a workpiece across multiple steps."]}),"\n",(0,s.jsx)(n.h2,{id:"consumers",children:"Consumers"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Consumer"}),(0,s.jsx)(n.th,{children:"Uses"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2D Canvas"}),(0,s.jsx)(n.td,{children:"WorkPieceViewArtifacts"}),(0,s.jsx)(n.td,{children:"Renders workpieces in screen space"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3D Canvas"}),(0,s.jsx)(n.td,{children:"StepRenderArtifacts"}),(0,s.jsx)(n.td,{children:"Renders full step in world space"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Simulator"}),(0,s.jsx)(n.td,{children:"JobArtifact"}),(0,s.jsx)(n.td,{children:"Accurate simulation of machine path"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Machine"}),(0,s.jsx)(n.td,{children:"JobArtifact G-code"}),(0,s.jsx)(n.td,{children:"Manufacturing output"})]})]})]}),"\n",(0,s.jsx)(n.h1,{id:"key-differences-from-previous-architecture",children:"Key Differences from Previous Architecture"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"DAG-based Scheduling:"})," Instead of sequential stages, artifacts are\ngenerated as their dependencies become available."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"State Management:"})," Node state is tracked in the DAG graph, not in\nindividual components."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ViewManager Separation:"})," Rendering for the 2D canvas is now handled\nby a separate ViewManager, not as part of the data pipeline."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Generation IDs:"})," Artifacts are tracked with generation IDs, allowing\nefficient reuse across document versions."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Centralized Orchestration:"})," The DagScheduler is the single point of\ncontrol for task launching and state tracking."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pure Cache Manager:"})," The ArtifactManager is now a simple cache,\ndelegating all state management to the DAG scheduler."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Invalidation Tracking:"})," Keys marked dirty before graph rebuild are\npreserved and re-applied after rebuild."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pending Work Detection:"})," Only ",(0,s.jsx)(n.code,{children:"PROCESSING"})," nodes count as pending work;\n",(0,s.jsx)(n.code,{children:"DIRTY"})," nodes may have unsatisfied dependencies (e.g., no view context)."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453(e,n,i){i.d(n,{R:()=>c,x:()=>a});var r=i(96540);const s={},t=r.createContext(s);function c(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);